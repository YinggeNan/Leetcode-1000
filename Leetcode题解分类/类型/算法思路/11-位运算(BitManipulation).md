
#### Hamming Distance (Easy)
>异或+统计二进制1个数

题目描述: 统计两个整型数的二进制位有多少位不同  
思路: 对x、y做异或操作，令结果res = x^y，数res的二进制表示有多少个1，从res的最低位数开始判断，res^1为1表示最低位为1，右移res一位如果res不等于0继续判断直到res等于0
#### Single Number (Easy)
>相同的数异或为0 + 与0异或不变

题目描述: 给一个数组，数组中只有一个数只出现了一次，其他数都出现两次，求该数  
思路: 根据两个相同的数异或结果为0，将数组中所有数异或得到的结果res就是所求唯一不重复的数  

#### Missing Number (Easy)
>相同的数异或为0 + 与0异或不变

题目描述: 给一个长度为n的数组，包含的元素值范围在0~n，但是0~n范围内只有一个元素缺失了不在数组中，求这个缺失的数
思路: 利用相同的数异或为0的原理
构建一个集合set，集合中包括"数组的所有index、数组所有元素值、n"，将set中所有元素互相异或，
其实就是数值范围0~n和缺少了一个值的数值范围0~n中的所有元素异或，自然就能得到缺少的那个数

#### leetCode-260.Single Number III
>相同的数异或为0 + 与0异或不变

题目描述: 给一个数组，其中只有两个数字分别只出现了一次，其他数字都出现了两次，请找出来这两个数字  
思路: 利用两个相同数字异或为0的原则。  
设这两个只出现了一次的数字为x、y，首先将数组中所有元素异或得temp = x^y，
利用temp^(-temp)可以得到temp的最右边第一个bit位为1(假设是第5bit位)的数temp1(形如10000),利用temp1可以区分出x和y，
假设x的第5bit也为1，迭代变量为i，再次遍历数组所有元素,将所有第5bit为1既temp1&i!=0的元素一起异或就能得到x的结果，
因为第五bit位为1的元素只有两种可能，要嘛是x，要嘛是除了x、y的其他元素，而该元素一定是成对的，如何求y同理

#### Reverse Bits-Easy
>&1得最低位+原数循环右移+新数循环左移

题目描述: 给一个int型数x，翻转x的所有比特位
思路: 定义一个左循环操作 "记录x的最高位，然后x<<1，最后将最低位值赋值为之前记录的最高位"，执行左循环操作32次既是翻转x，
可以定义一个放int型的所有二进制的容器container，每次先左移动container一位，腾出最低位来放从x中取出的最低位，
然后对x右移动一次，执行上述操作32次即可

#### <strong>不用额外变量交换两个整数<strong/>
```
a = a ^ b;
b = a ^ b;
a = a ^ b;
```
#### Power of Two-Easy
题目描述: 判断一个int型数是不是2的n次方  
思路: 这个数的二进制位只有一个1，二进制位只有一个1的数x满足x&(x-1)为0，或者Integer.bitCount(x)返回1

#### Power of Four-Easy

题目描述: 判断一个int型数x是不是4的n次方  
思路: 这个数x必须>3，且其二进制位表示上有且仅有一个1在奇数位置上
如何表示二进制位只有一个1？   
x&(x-1)==0为true，或者Integer.bitCount(x)返回1
如何表示只有一个1且在奇数位置上？  
(x&(x-1)==0)&&(x&(0b01010101010101010101010101010101))返回true

#### Binary Number with Alternating Bits-Easy
题目描述: 判断一个数的位级表示是否不会出现连续的 0 和 1,输入n满足1 <= n <= 2^31 - 1  
思路: 如x = 1010,右移动一位得0101; 则x^(x>>1)为1111，这是一个二进制表示为从左到右都是1的数， 
二进制表示为从左到右都是1的数temp满足temp&(temp+1)为0  
所以只要x^(x>>1)的结果为从左到右都是1的数，那么x就符合条件  
证明:
(1)有连续1，比如x = 1101, x>>1为0110, 1101^0110为1011  
(2)有无连续0，比如x = 1001, x>>1为0100, 1001^0100为1101  

#### Number Complement-Easy
题目描述: 给一个int型正数，求其补码，补码策略为将其二进制表示的从最高位1开始到最低位的bit都反转  
思路: 题目隐含表示了从所给数的二进制表示的左边第一个为1的bit位开始直到最右边的bit位，将此范围内的所有bit位翻转，如何翻转就是将对应的每个bit位都和1异或，比如对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码00000111
算法：通过找到所给数x的左边第一个1的位置，比如是从左到右的第5位，那么2^(5+1)-1就是要求的掩码，  
设position = 1<<30, 判断x&position==0，结果为false则，则右移动position一位,直到判断为true则表示找到了该位置，则position<<1-1为所求掩码

#### Sum of Two Integers-Easy
题目描述: 不用加法符号+实现加法操作  
思路: a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位，但是这个进位可能大于1，所以需要递归  
```
public int getSum(int a, int b) {
    return b == 0 ? a : getSum((a ^ b), (a & b) << 1);
}
```
## Maximum Product of Word Lengths-Medium
题目描述: 给一个字符串数组，求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符    
思路: 关键是判断两个字符串是否有相同字符，因为只有26个字母，所以完全可以用一个int数据的32bit来判断一个字符串"使用过了"哪些字母，     
比如使用了a就让一个int型变量的最低bit为1，其他同理，则只需要O(N)空间就可以记录所有字符串分别使用了哪些字母，   
如何判定两个字符串是否使用了同样的字母呢？比如字符串A使用变量aFlag，字符串B使用变量bFlag，只要(aFlag&bFlag)==0为true那么就没有使用同样的字母，   
因为只要A和B使用了同样的字母那么aFlag和bFlag就必然在同一bit上都有1那么&操作后结果中必然有一个bit为1，那么就必然不等于0 

#### Counting Bits-Medium
题目描述: 统计从 0 ~ n 每个数的二进制表示中 1 的个数  
思路: 使用动态规划，定义dp[i]表示数字i里面的二进制1的个数，则dp[i] = dp[i>>1] + (dp[i]&1);递归出口dp[0]为0   
Take number X for example, 10011001.
Divide it in 2 parts:
<1>the last digit ( 1 or 0, which is " i&1 ", equivalent to " i%2 ")
<2>the other digits (the number of 1, which is " f[i >> 1] ", equivalent to " f[i/2]")

#### leetCode-137.[Single Number II (medium)](https://leetCode-cn.com/problems/single-number-ii/)
#### Complement of Base 10 Number (medium)