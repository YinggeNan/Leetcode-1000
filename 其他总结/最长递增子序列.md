## 解法1，动态规划
### 尝试：
(1)定义dp[n]为以数组nums的index=n的元素结尾的最长摆动子序列，求dp[n-1]和dp[n]的递推关系，  
dp[n-1]和dp[n]之间没有明显的递推关系
(2)定义up[i]为以index=i结尾的最长上升子序列,donw[j]为以index=j结尾的最长下降子序列，这样的定义也明显有问题， 
up[i-1]也无法得到up[i],可能以index=i-2结尾的最长上升摆动子序列大于index=i-1的上升摆动子序列
### 定义
up[n]为index范围[0~n]中以某一个元素结尾的最长上升摆动子序列  
down[n]为index范围[0~n]中以某一个元素结尾的最长下降摆动子序列  
### 讨论
1.因为摆动就是相邻两个元素大小变化，所以讨论nums[n]和nums[n-1]的大小关系
2.「上升摆动序列」当且仅当该序列是摆动序列，且最后一个元素呈上升趋势。如序列 [1,3,2,4][1,3,2,4] 即为「上升摆动序列」。    
3.「下降摆动序列」当且仅当该序列是摆动序列，且最后一个元素呈下降趋势。如序列 [4,2,3,1][4,2,3,1] 即为「下降摆动序列」。   
3.对于长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。  
4.序列中的某个元素被称为「峰」，当且仅当该元素两侧的相邻元素均小于它。如序列 [1,3,2,4][1,3,2,4] 中，33 就是一个「峰」。  
5.序列中的某个元素被称为「谷」，当且仅当该元素两侧的相邻元素均大于它。如序列 [1,3,2,4][1,3,2,4] 中，22 就是一个「谷」。  
6.对于位于序列两端的元素，只要有一侧的相邻元素小于或大于它，我们也称其为「峰」或「谷」。如序列 [1,3,2,4][1,3,2,4] 中，11 也是一个「谷」，4 也是一个「峰」。  
7.预处理删除重复元素：因为一段相邻的相同元素中我们最多只能选择其中的一个，所以我们可以忽略相邻的相同元素。
8.现在假定序列中任意两个相邻元素都不相同，即要么左侧大于右侧，要么右侧大于左侧。  
9.对于序列中既非「峰」也非「谷」的元素，我们称其为「过渡元素」，如序列 [1,2,3,4][1,2,3,4] 中，22 和 33 都是「过渡元素」 
#### up[n]
##### a.nums[n-1]等于nums[n]
up[n] = up[n-1]
##### b.nums[n-1]>nums[n]
要的是上升子序列，而从n-1到n递减,则dp[n] = dp[n-1]
##### c.nums[n-1]<nums[n]
无论n-1是不是[1~n-1]范围内的最长上升子序列的最后一个元素，如果由up[n-1]转化为up[n]的话就是up[n-1]
因为up[n-1]和down[n-1]都可以转化为up[n],而down[n-1]对应的最长递减摆动序列s1的最后一个元素index=x必然是index=n的左边第一个波谷，因为如果是index=x左边第二个波谷
那么index=x右边又有一个波峰和波谷了，所以序列s1加上右边的index=n的元素可以组成一个上升子序列
up[n] = max(up[n-1], down[n-1]+1)
#### down[n]同上
#### 递推方程
![](..\\pictures\\longest-wiggle-subsequence-4.png)

## 解法2，对解法1动态规划的优化
注意到up[i]只需要up[i-1]或者down[i-1]，down[i]同理，既后一个状态只需要前一个状态来转移即可，所以可用两个变量up,down代替两个数组
所以最长摆动子序列总结为："n-1到n上升则更新上升变量up，n到n-1下降就更新下降变量down
```
    if(nums[i]<nums[i-1]){
        down = Math.max(down, up+1);
    }else if(nums[i]>nums[i-1]){
        up = Math.max(up, down+1);
    }
```