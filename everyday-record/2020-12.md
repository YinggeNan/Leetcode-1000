#####
```
题目描述:
思路:
```
#### 2020-12-20
##### Hamming Distance (Easy)
```
题目描述: 统计两个数的二进制位有多少位不同
思路: 对x、y做异或操作，令结果res = x^y，数res的二进制表示有多少个1，
从res的最低位数起，res^1为1表示最低位为1，然后右移res一位继续判断直到res为0
```
#####  Single Number (Easy)
```
题目描述: 给一个数组，数组中只有一个数只出现了一次，其他数都出现两次，求该数
思路: 根据两个相同的数异或结果为0，将数组中所有数异或得到的结果res就是所求唯一不重复的数
```
##### Missing Number (Easy)
```
题目描述: 数组包含了n个不同的数，每个数范围都在0~n之间，所以数组缺少了一个数x，
有了x，数组中所有数就能成为一个连续序列，输入例如[3,0,1]
思路: 利用相同的数异或为0，数组的所有index为0到n-1加上数组长度n就是[0,n]，所有值为[0,n]缺少了一个，
所以将所有index和所有值一起异或，再异或一个数组长度，结果就是缺少的那个值
```
#### 2020-12-21
##### Single Number III
``` 
题目描述: 给一个数组，其中只有两个数字分别只出现了一次，其他数字都出现了两次，请找出来这两个数字
思路: 利用两个相同数字异或为0的原则。设这两个只出现了一次的数字为x、y，首先将数组中所有元素异或得temp = x^y，
利用temp^(-temp)可以得到temp的最右边第一个bit位为1(假设是第5bit位)的数temp1(形如10000),利用temp1可以区分出x和y，
假设x的第5bit也为1，迭代变量为i，再次遍历数组所有元素,将所有第5bit为1既temp1&i!=0的元素一起异或就能得到x的结果，
因为第五bit位为1的元素只有两种可能，要嘛是x，要嘛是除了x、y的其他元素，而该元素一定是成对的，如何求y同理
```
##### Reverse Bits-Easy
```
题目描述: 给一个int型数x，翻转x的所有比特位
思路: 定义一个左循环操作 "记录x的最高位，然后x<<1，最后将最低位值赋值为之前记录的最高位"，执行左循环操作32次既是翻转x，
可以定义一个放int型的所有二进制的容器container，每次先左移动container一位，腾出最低位来放从x中取出的最低位，
然后对x右移动一次，执行上述操作32次即可
```
##### 不用额外变量交换两个整数
```
代码:
a = a ^ b;
b = a ^ b;
a = a ^ b;
```
##### Power of Two-Easy
```
题目描述: 判断一个int型数是不是2的n次方
思路: 这个数的二进制位只有一个1，二进制位只有一个1的数x满足x&(x-1)为0，或者Integer.bitCount(x)返回1
```
##### Power of Four-Easy
```
题目描述: 判断一个int型数x是不是4的n次方
思路: 这个数x必须>3，且其二进制位表示上有且仅有一个1在奇数位置上
如何表示二进制位只有一个1，x&(x-1)==0为true，或者Integer.bitCount(x)返回1
如何表示只有一个1且在奇数位置上，(x&(x-1)==0)&&(x&(0b01010101010101010101010101010101))返回true
```
#### 2020-12-22
##### Binary Number with Alternating Bits-Easy
```
题目描述: 判断一个数的位级表示是否不会出现连续的 0 和 1,输入n满足1 <= n <= 2^31 - 1
思路: 如x = 1010,右移动一位得0101; 则x^(x>>1)为1111，这是一个二进制表示为从左到右都是1的数，
二进制表示为从左到右都是1的数temp满足temp&(temp+1)为0
所以只要x^(x>>1)的结果为从左到右都是1的数，那么x就符合条件
证明:
(1)有连续1，比如x = 1101, x>>1为0110, 1101^0110为1011
(2)有无连续0，比如x = 1001, x>>1为0100, 1001^0100为1101
```
##### Number Complement-Easy
```
题目描述: 给一个int型正数，求其补码，补码策略为将其二进制表示的从最高位1开始到最低位的bit都反转
思路: 题目隐含表示了从所给数的二进制表示的左边第一个为1的bit位开始直到最右边的bit位，将此范围内的所有bit位翻转，
如何翻转就是将对应的每个bit位都和1异或，比如对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码00000111
算法：通过找到所给数x的左边第一个1的位置，比如是从左到右的第5位，那么2^(5+1)-1就是要求的掩码，
设position = 1<<30, 判断x&position==0，结果为false则，则右移动position一位,直到判断为true则表示找到了该位置，则position<<1-1为所求掩码
```
##### Sum of Two Integers-Easy
```
题目描述: 不用加法符号+实现加法操作
思路: a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位，但是这个进位可能大于1，所以需要递归
代码
public int getSum(int a, int b) {
    return b == 0 ? a : getSum((a ^ b), (a & b) << 1);
}
```
##### Maximum Product of Word Lengths-Medium
```
题目描述: 给一个字符串数组，求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符
思路: 关键是判断两个字符串是否有相同字符，因为只有26个字母，所以完全可以用一个int数据的32bit来判断一个字符串"使用过了"哪些字母，
比如使用了a就让一个int型变量的最低bit为1，其他同理，则只需要O(N)空间就可以记录所有字符串分别使用了哪些字母，
如何判定两个字符串是否使用了同样的字母呢？比如字符串A使用变量aFlag，字符串B使用变量bFlag，只要(aFlag&bFlag)==0为true那么就没有使用同样的字母，
因为只要A和B使用了同样的字母那么aFlag和bFlag就必然在同一bit上都有1那么&操作后结果中必然有一个bit为1，那么就必然不等于0
```
##### Counting Bits-Medium
```
题目描述: 统计从 0 ~ n 每个数的二进制表示中 1 的个数
思路: 使用动态规划，定义dp[i]表示数字i里面的二进制1的个数，则dp[i] = dp[i>>1] + (dp[i]&1);递归出口dp[0]为0
Take number X for example, 10011001.
Divide it in 2 parts:
<1>the last digit ( 1 or 0, which is " i&1 ", equivalent to " i%2 ")
<2>the other digits (the number of 1, which is " f[i >> 1] ", equivalent to " f[i/2]")
```
#### 2020-12-23
##### Is Graph Bipartite?-medium
```
题目描述：判断是否是二分图
思路：一个二分图，任取一条边，总能把图的所有node分为两个set，则该边的node1在set1中，node2在set2中,
使用着色法，用两种颜色去给图的所有节点着色，对一个节点着色时，如果这个节点没有颜色那么用比如对node1着色blue(1)，
则对node1所有邻接点着色red(-1)，
```
##### Course Schedule-medium
```
题目描述: 一个课程可能会先修课程，判断给定的课程学习顺序是否合法
思路:这是一个拓扑排序问题，只需要判定图里有无环就好，只有有向无环图DAG才有拓扑排序
获得拓扑排序的BFS算法是"图有n个节点，定义graph[n][n]和indgree[n]，graph[n][n]为图的邻接矩阵，indgreee[i]表示节点i的入度，
扫描图的所有边初始化raph[n][n]和indgree[n]，然后将indegree[i]为0的所有节点i加入到队列queue中，
从queue中poll出一个节点i，删除从i出发的所有边(将graph[i][n]>1的都减1），入度减少1之后为0的节点加入到queue中继续循环直到queue为空
queue中poll出的所有节点形成一个拓扑序列
本题只需要判断是否有环，所以不需要得到拓扑序列，只需要判定加入到queue中的节点数量是否等于n即可，等于n则无环
```
##### Course Schedule II
```
描述: 得到拓扑排序
思路：和Course Schedule一样用BFS即可，不过DFS如何做呢？
```
####  2020-12-24
##### Redundant Connection-medium
```
union-find，判断两个node是否在一个连通图中
UnionFind类包含parent[]、rank[]成员，find一个node，
得到该node所在树的根节点，find操作执行path compression，
union操作执行按秩合并，秩小的合并到秩大的
```
##### Move Zeroes-easy  
```
题目描述: 把数组中的 0 移到末尾
思路: 重插入数组
```
##### Reshape the Matrix-easy
```
思路: 重插入二维数组
```
##### Max Consecutive Ones-easy
```
题目描述: 找出数组中最长的连续 1
思路: 设置两个变量，全局连续1 globalAcount、单次扫描连续1 partialCount，
遍历数组，遇到1则partialCount加1，遇到0则设置globalAcount为max(globalAcount为max, partialCount)，
且partialCount重置为0
```
##### Search a 2D Matrix II -easy
```
对于每行从左到右升序，每列从上到下升序的matrix，
查找某个元素，从右上角元素x开始，x>target则转向x的left，
x<target则转向x的down
```
#### 2020-12-25
##### Kth Smallest Element in a Sorted Matrix-Medium
```
题目描述: 一个矩阵，从上到下递增排序，从左到右递增排序，求矩阵中第k小的数
思路:
堆解法：最小堆，对于矩阵来说最小的数肯定在第一行中，那么第二小的数在哪里呢？设set有且仅有第一行的所有数，最小的数为x，
那么将x下方(第二行)的y加入到set中，此时set中最小的数就是第二小的数，同理循环k-1即可得到最小的数
```
```
二分搜索：因为是二维数组，所以不能是index range的二分搜索，只能是value range的二分搜索
核心思想就是找到一个数x(存在于矩阵中)，让矩阵中所有小于x的数有k-1个，那么x就是第k小的数了,设矩阵最大值为max，最小值为min
对[min,max]范围进行二分搜索，low=min，high=max+1(要让mid的值有为max的可能，所以low不能为max）\，
得mid=left+(right-left)/2, 遍历数组nums统计所有小于等于mid的数的个数count，若count<=k则说明low到mid之间不存在x，
则low=mid+1，若count>k则x就在low到mid之间，high=mid, 最后low 和high会相遇于x。
```
##### Find the Duplicate Number-Medium
```
题目描述: n+1个数放到长度为n的数组里，且每个数取值范围1~n,只有一个重复数字
思路:
快慢指针：对于这种将集合S中的所有元素映射到自身集合S的问题，可以用tortiose and hare algorithm算法
输入数组为nums，将其一个index看作一个节点，则其所有index的指向关系构成了一个循环链表，
fast指针步长为2(nums[nums[fast])，slow指针步长为1(nums[slow]
第一个循环找相遇点：初始为fast=nums[nums[0]], slow=nums[0]，fast步长2，slow步长1出发，相遇于x
第二个循环找重复元素(cycle开始节点)：fast从x，slow从0开始都以步长为1继续出发，最后相遇于重复元素值
```
```
二分搜索：value range搜索，对[1,n]进行搜索，设low=1, high = n+1(为了mid能为n), mid=low+(high-low)/2;
统计数组里小于等于mid(为什么有小于的情况，因为可能数组的所有数都为同一个值)的数count，如果count<mid，
则说明重复的数在[mid+1,high]之间则low = mid+1;如果count>mid，说明重复的数在[low,mid]之间则high=mid
最后low和high会相遇于mid
```
##### Set Mismatch-Easy
``` 
题目描述: 
将1~n这n个数字放到长为n的数组nums中，将其中一个数字x从其位置上删除，
并放置了一个1~n的非x的其他数字，也就是说有一个重复数字
思路:
排序解法：设数组为nums，长L，排序数组，然后从0开始遍历数组，对比i和i+1位置的数，检测到重复后，
将从i+1到L-1位置的所有元素左移一位，然后再次遍历整个数组，当nums[i]!=i+1时，i+1就是missing元素
```
```
交换解法：核心思想就是将值为x的值元素放到x-1的位置上，扫描数组，判断当前位置i上的值nums[i]是否为i+1，
如果是，则继续判断下一个位置，如果不是，则将nums[i]放到其正确的位置num[i]-1上，放之前也要判断位置上nums[i]-1
是否有值，若有值则继续判断下一个位置，没有则交换i和nums[i]-1的位置，交换后继续判断当前位置i上的值是否满足
条件，循环处理直到不当前位置有正确的值或要放的位置已经有正确值为止
```
#### 2020-12-26
##### Beautiful Arrangement
```
题目描述: 有一个set包含了从1~N的所有元素，要得到这样的序列，index为i上的元素value满足
index能被value整除或者value能被index整除，求所有这样的序列的数量，index从1开始
思路: DFS + 回溯; 状态数组的使用; 递归出口如何定义,这里只需要求符合条件的序列的数量，所有不需要返回真正的序列
递归函数定义一个参数pos,表示本次调用是放置pos位置的值，隐含表示1~(pos-1)都找好了，所以pos为N+1时表示找到一个符合
条件的序列
code: https://leetcode.com/submissions/detail/435610590/
```
##### Permutations
```
题目描述: 全排列
思路: DFS + 回溯；状态数组的使用(本题也可以不使用状态数组，看一个元素有没有使用过直接搜索currentPermutation也行
不过这样时间复杂度为O(N); currentPermutation最后加入globalPermutation时要放置currentPermutation的copy
递归出口是currentPermutation的长度为输入数组的长度
参考: https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)
```
##### Degree of an Array (Easy)
```
题目描述: 找到给定数组的一个子数组(必须是从原数组连续元素截取)的最高频率和原数组一致，该子数组长度最小
思路: 找到所有可能的最大频率的元素，计算这些元素的lastPos-firstPos+1的最小值
Code: https://leetcode.com/submissions/detail/435633431/
进阶: 一次遍历解决,用一个countMap来统计每个元素出现的频率，用一个firstMap来记录每个元素第一次出现的位置，
degree变量表示当前频率最大值，minLength表示所求最小连续子数组长度，遍历数组，对于每个当前遍历的元素x
如果x的频率大于degree，则更新degree并赋值minLenghth为currentPosOfx-firstPosOfx+1，如果其频率等于degree，
则minLenghth = math.min(minLenghth, currentPosOfx-firstPosOfx+1)
参考: https://leetcode.com/problems/degree-of-an-array/discuss/124317/JavaC%2B%2BPython-One-Pass-Solution
```
#### 2020-12-29
##### Toeplitz Matrix-Easy
```
题目描述: 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵
思路:
(1)解法1:遍历第一排和第一列的每个元素，遍历到一个元素a，坐标为(x,y)时，就一直沿着其右下方对角线遍历，既x++,y++，
检测是否对角线上的元素一样，这样需要检测是否越界
(2)解法2:遍历row range [0,matrix.length-1], column range [0,matrix[0].length-1]的每个元素a，坐标为(x,y)，检测
其matrix[x][y]是否等于matrix[x+1][y+1]即可，比解法1简洁很多
```
##### Array Nesting-Medium
```
题目描述: https://leetcode-cn.com/problems/array-nesting/
思路:可以证明任给一个index=x开始，比如x=1，然后得到index=1上的值A[x]，
用A(x)作为index继续寻找，最后会找到一个index=y，a[y]必然等于x，
既上述的index必然形成一个环，而A[index]就是指引环中一个节点index到另一个节点index的方向
所有0到N-1的这N个index可以分为好几组，每一组都形成一个环，且每一组的环都和别的组的环不相交，题目要求的
就是这些环中的最大环长度，所以我们遍历任意一个元素都只需要遍历一遍，因为这个元素只属于一个环，
所以一个index被遍历后就标记这个index，比如可以设置A[index]为-1，当遍历到一个A[x]为-1时直接i跳过即可
```
##### Max Chunks To Make Sorted-Medium
```
题目描述: 数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，
并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同

思路: 设一个当前index=i的最大值indexMax，为从index=0开始到当前位置index=i的最大值，如果
indexMax等于i则可以划分的块加1
```
#### 2020-12-30
##### 字符串循环移位包含
```
题目描述: 给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含
思路: s1循环移位后的序列肯定被s1s1包含，所以只需要判断s2是否被s1s1包含即可
```
##### 字符串循环移位
```
题目描述: 求将字符串向右循环移动 k 位，比如s="abcd123"，循环右移动3位得"123abcd"
思路:设源字符串长度为a,index为0~(a-1), 则将 a-1-k~a-1、0~a-2-k两段分别翻转，再将
整个字符串翻转
```
##### 字符串中单词的翻转
```
题目描述: 输入形如s="I am a student",要得到t="student a am I"
思路: 将每个单词分别翻转，再将整个字符串翻转
```
##### Valid Anagram (Easy)
```
题目描述: 两个字符串包含的字符串是否完全相同，字符串只包含小写字母
思路:用map存储{character:frequency},或者用长度为26的数组存储频率
```
##### Longest Palindrome (Easy)
```
题目描述: 计算一组字符集合中可以组成的回文字符串的最大长度
思路: 偶数个数字符直接计入回文字符串，奇数个数的字符-1就是偶数了也就可以
计入回文字符串了，如果最后还有单个字符串也需要计入回文，因为可以
放在回文字符串的中间
```
##### Isomorphic Strings (Easy)
```
题目描述: 判断字符串s、t是否同构，如何唯一标识每个mapping关系
思路:如果存在一个字符mapping为'x'->'y',那么用'x'->1,'y'->1也可以
表示，只要1唯一标识字符串s中的字符'x',字符串t中的字符'y'即可
s、t长度均为t，用两个长度为256(ASCII所有字符数量)来分别标识
index从0~t-1的s、t中的字符map的数字；

```
##### Palindromic Substrings (Medium)
```
题目描述:  回文子字符串个数
思路: 中心展开法，奇数展开和偶数展开
```
##### Palindrome Number (Easy)
```
题目描述: 不使用额外空间，判断一个整数是否是回文数
思路: 可以看作是循环右移动，如何实现循环右移动呢？
设输入数字为number，构建一个新数字newNumber
每次number的右移的一位，右移掉的数字为x，将x加到newNumber最低位
当number为0后，判断newNumber和 原来numbe是否相同
```
##### Count Binary Substrings (Easy)
```
题目描述: 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数
思路: 统计连续1或0的数量，得到一个统计连续数数组，比如对"11000111"，
其统计连续数组为[2,3,3]，对两个相邻的连续不同数字比如"11000"而言，
其符合条件的子序列有"10","1100"两个，Math.min(2,3);
所以输入二进制字符串的统计连续数组为[2,3,3]时, 则连续1和连续0相同的序列
个数为Math.min(2,3)+Math.min(3,3)=5个
```
