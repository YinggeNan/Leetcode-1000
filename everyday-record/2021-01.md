#####
```
题目描述:
思路:
```
#### 2021-1-04
##### Implement Queue using Stacks
```
题目描述: 用栈实现队列
思路: 栈LIFO，队列FIFO，两个栈就可以FIFO
push进入栈A，poll从栈B出来，当栈B为空时，将栈A所有元素出栈再依次入栈B
```
##### Implement Stack using Queues (Easy)
```
题目描述: 用队列实现栈
思路: 队列FIFO，队列进入一个元素x时，将队列中所有出x的所有元素出队再入队
```
##### Min Stack (Easy)
```
题目描述: 最小(大)值栈
思路: 两个栈dataStack、minStack
```
##### Min Queue-编程之美3.7
```
题目描述: 最小(大)值队列，要求"O(1)时间获得当前队列中的最小(大)值"
思路:
(1)堆,将所有元素放进最小/大堆中，入队、出队时间复杂度为O(logN)
(2)用两个栈s1、s2实现队列，那么队列的最小值就是min(s1.min(), s2.min())，入队、出队时间复杂度为O(1)
上述两种方法都是通过空间换时间达到了获取当前队列最小值时间复杂度为O(1)
```
##### Valid Parentheses (Easy)
```
题目描述: 对输入只有三种括号的字符串检测是否括号匹配，()[]{}
思路: 栈，扫描输入字符，当栈为空时字符入栈，当栈不为空时查看栈顶字符和扫描字符是否匹配
如果匹配则栈poll，不匹配则入栈，扫描输入字符串完毕后，如果栈为空则括号匹配
```
##### Daily Temperatures (Medium)
```
题目描述: 数组中元素与下一个比它大的元素之间的距离
思路: 遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，
说明栈顶元素的下一个比它大的数就是当前元素
```
##### Next Greater Element II (Medium)
```
题目描述: 循环数组中比当前元素大的下一个元素
思路: 和Daily Temperatures类似，不过对于位置为index的数而言，可以向前查找，
所以遍历数组范围设置为两倍长度
```
#### 2021-1-05
##### Maximum Depth of Binary Tree (Easy)
```
题目描述: 求树的高度
思路: 树高度 = Math.max(左子树高度,右子树高度) + 1，设maxDepth(node)返回node节点深度
则maxDepth(node) = Math.max(maxDepth(node.left), maxDepth(node.right)) + 1
```
##### Balanced Binary Tree (Easy)
```
题目描述: 判断一颗树是否为平衡树
思路: 平衡树的每一个节点的左右子树的差值不超过1
设maxDepth(node)返回node节点深度，遍历根节点为root的树，设置一个全局boolean变量flag，
对节点i来说:当Math.abs(maxDepth(i.left)-maxDepth(i.right))<=1，我们称节点i平衡，否则节点i不平衡，则置flag=false
只有以root为根节点的树的所有节点都平衡时该树才平衡
```
##### Diameter of Binary Tree (Easy)
```
题目描述: 两节点的最长路径
思路: 最长路径一定经过了某个子树的根节点，所以我们求以每个节点为根节点的子树中经过该根节点的最长路径，所有路径最大值为答案
设maxDepth(node)返回node节点深度，遍历根节点为root的树，设全局变量max = 0;节点i为根节点的子树中经过节点i的最长路径
maxLength(i) = maxDepth(i.left) + maxDepth(i.right)
max = Math.max(maxLenght(i),max),求所有节点maxLength(i)的最大值既为树的最长路径
```
##### Invert Binary Tree (Easy)
```
题目描述: 翻转树的所有节点
思路: 要对每一个节点都要翻转，叶子节点也翻转，这样对所有节点效果一样
TreeNode temporaryLeft = root.left; // 暂存left指针，后面left指针会指向新的节点
root.left = invert(root.right);
root.right = invert(temporaryLeft);
递归出口: null节点直接返回null
```
##### Merge Two Binary Trees (Easy)
```
题目描述: 归并两棵树
思路: 构建新树，两个指针遍历t1、t2同一位置的节点，新树根节点 = 两个子树的根节点之和，
新树跟节点值 = t1节点 + t2根节点的和（t1、t2可能为空)
新树左子树 = merge t1、t2的左子树
新树右子树 = merge t1、t2的右子树
```
##### Path Sum (Easy)
```
题目描述: 判断路径和是否等于一个数
思路: 遍历所有路径计算路径和，路径和是指路径上所有节点值的总和，只要有一条路径和等于给定的数则满足条件
要计算路径和，递归函数定义时传入currentSum表示父节点的累计路径和
这里的递归函数不同于计算树的深度，计算树的深度的递归函数是被调用的函数返回从叶子节点到左右子树的根节点的深度，
而此处被调用函数是接受来自父节点的累计路径和
```
```
(1)定义pathSum(TreeNode root, int currentSum, int sum)返回root节点是否有满足条件的序列
    // 要计算路径和，传入currentSum表示父节点的累计路径和
    public boolean pathSum(TreeNode root, int currentSum, int sum){
        // 说明root前面的节点都没有返回true，则这里肯定不满足条件了
        if(root == null){
            return false;
        }
        currentSum += root.val;
        // 叶子节点可以计算路径和了，且路径和等于sum
        if(root.left==null && root.right==null && currentSum==sum){
            return true;
        }
        return pathSum(root.left, currentSum, sum) || pathSum(root.right, currentSum, sum);
    }
```
```
(2)定义一个全局变量flag=fasle,发现一个满足条件的路径时置flag=true
    private boolean flag = false;
    public void pathSum(TreeNode root, int currentSum, int sum){
        // 说明root前面的节点都没有返回true，则这里肯定不满足条件了
        if(root == null){
            return;
        }
        currentSum += root.val;
        if(root.left==null && root.right==null && currentSum==sum){
            flag = true;
        }
        pathSum(root.left, currentSum, sum);
        pathSum(root.right, currentSum, sum);
    }
```
##### Path Sum III
```
题目描述: 统计路径和等于一个数的路径数量，路径不一定要从root节点开始，也不一定要以叶子节点结束，但必然是向下的
思路: 对一个节点i来说，设f(i) = 从i开始向下的所有路径中等于sum的路径，遍历所有节点，对每个节点求f累计和，累加所有f
两种写法，全局变量，和函数返回值返回有效路径数量
(1)全局变量:https://leetcode.com/submissions/detail/438932880/
(2) 返回值解法
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
        return ret;
    }
    private int pathSumStartWithRoot(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = 0;
        if (root.val == sum) ret++;
        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
        return ret;
    }
```

##### 总结
##### 树结构很适合写递归的解法，因为树本身就是递归定义的
##### (1)抽象思维
解决很多题目时，就是抽象的思考题目的意思，并不需要考虑是前序、中序、还是后序地去遍历树中的节点
比如"求树的高度这道题目"(Maximum Depth of Binary Tree)，正确的思考方式就是树高 = 1 + Math.max(左子树高+右子树高)，这就是一个前序遍历，
但是这是不是前序遍历并不重要，所以如果题目规定必须采用前序、中序、后续中的某一种来解决，就不需要考虑遍历顺序
##### (2)全局变量+递归函数
全局变量+递归函数：
有返回值的递归函数：递归函数的返回值只是为了完成递归函数的工作的中间产物，这和我们通常写的函数有些区别
不管是有返回值的递归还是void递归函数，全局变量才是递归函数的最终结果
##### (3)树结构题目-两种写法
1.void递归函数+全局变量：全局变量才是最终结果
2.有返回值的递归函数：返回值是最终结果
比如题目 Path Sum III
##### (4)考虑遍历顺序
当解决一个问题时，需要显式地遍历这个树地所有节点，然后对遍历的每个节点x做操作时
这时就可以来考虑是前序、后续、中序了，不过都一样
##### (5)对于路径类题目，计算路径长度或计算路径上所有节点val和时
1.给递归函数传入父节点累计和
2.对子节点调用递归函数时，将目标sum更新为sum-父节点累计和
##### (6)路径类问题，对于从root节点出发且可能会多个符合条件的返回值递归函数写法
```
    private int pathSumStartWithRoot(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = 0;
        if (root.val == sum) ret++;
        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
        return ret;
    }
```
