#####
```
题目描述:
思路:
```
#### 2021-1-04
##### Implement Queue using Stacks
```
题目描述: 用栈实现队列
思路: 栈LIFO，队列FIFO，两个栈就可以FIFO
push进入栈A，poll从栈B出来，当栈B为空时，将栈A所有元素出栈再依次入栈B
```
##### Implement Stack using Queues (Easy)
```
题目描述: 用队列实现栈
思路: 队列FIFO，队列进入一个元素x时，将队列中所有出x的所有元素出队再入队
```
##### Min Stack (Easy)
```
题目描述: 最小(大)值栈
思路: 两个栈dataStack、minStack
```
##### Min Queue-编程之美3.7
```
题目描述: 最小(大)值队列，要求"O(1)时间获得当前队列中的最小(大)值"
思路:
(1)堆,将所有元素放进最小/大堆中，入队、出队时间复杂度为O(logN)
(2)用两个栈s1、s2实现队列，那么队列的最小值就是min(s1.min(), s2.min())，入队、出队时间复杂度为O(1)
上述两种方法都是通过空间换时间达到了获取当前队列最小值时间复杂度为O(1)
```
##### Valid Parentheses (Easy)
```
题目描述: 对输入只有三种括号的字符串检测是否括号匹配，()[]{}
思路: 栈，扫描输入字符，当栈为空时字符入栈，当栈不为空时查看栈顶字符和扫描字符是否匹配
如果匹配则栈poll，不匹配则入栈，扫描输入字符串完毕后，如果栈为空则括号匹配
```
##### Daily Temperatures (Medium)
```
题目描述: 数组中元素与下一个比它大的元素之间的距离
思路: 遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，
说明栈顶元素的下一个比它大的数就是当前元素
```
##### Next Greater Element II (Medium)
```
题目描述: 循环数组中比当前元素大的下一个元素
思路: 和Daily Temperatures类似，不过对于位置为index的数而言，可以向前查找，
所以遍历数组范围设置为两倍长度
```
#### 2021-1-05
##### Maximum Depth of Binary Tree (Easy)
```
题目描述:  给一颗二叉树，求其高度

思路: 树高度 = Math.max(左子树高度,右子树高度) + 1

递归函数
    定义：int maxDepth(TreeNode node):返回node节点深度
    递归出口：node为null时返回0
    关键点：根节点root深度为maxDepth(root) = Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
```
##### Balanced Binary Tree (Easy)
```
题目描述: 给一颗二叉树，判断其是否为平衡树

思路: 判断平衡树的每一个节点的左右子树的差值都不超过1即可

递归函数
    定义1：从思路来看关键是对对每个节点都做一个判断左右子树高度差的操作，所以可以拆分为遍历每个节点，
        然后在遍历到该节点时再求其左右子树高度，但是这样时间复杂度很高
    定义2：关键词是"遍历"+"高度/深度",所以对"求树高度函数"做一个变形，让其在得到得到左右子树高度时顺便判断高度差是否满足
         int intmaxDepth(node):返回node节点深度 ; 设置一个全局boolean变量flag=true
    递归出口
    关键: 遍历根节点为root的树,当每个节点得到其左右子树高度时，判断左右子树高度差是否满足小于等于1，不满足置flag = false
```
##### Diameter of Binary Tree (Easy)
```
题目描述: 给一颗二叉树，求其中任意两个节点之间的的最长路径长度，这个路径不一定要经过该树的根节点

思路: 
最长路径一定经过了某个子树的根节点，所以我们求得所有子树中经过了本子树根节点的最长路径中的最长路径者即为答案
在以node为根节点的子树中经过node的最长路径 = node左子树高度 + node右子树高度(一个节点高度为1)

递归函数
    定义：int maxDepth(TreeNode node):返回node节点深度; 设全局变量maxLength = 0; // 因为题目所求与节点深度有关
    关键点：
        递归出口：node == null 返回0
        返回值实现:  node的深度为Math.max(maxDepth(node.left), maxDepth(node.right))+1
        对每个节点i得到其左右子树节点高度时，更新maxLength = Math.max(maxLength, maxDepth(i.left) + maxDepth(i.right))
```
##### Invert Binary Tree (Easy)
```
题目描述: 给一颗二叉树，翻转其所有节点

思路: 将每一个节点的左右子树交换

递归函数
    定义：void invert(TreeNode root); // 交换以root为根节点的树的所有节点的左右子节点
    递归出口: root == null时retur
    关键: 对root节点翻转
        TreeNode temporaryLeft = root.left; // 暂存left指针，后面left指针会指向新的节点
        root.left = invert(root.right);
        root.right = invert(temporaryLeft);
```
##### Merge Two Binary Trees (Easy)
```
题目描述: 给两颗二叉树s、t，归并s、t为一颗新树，要求当同一位置s没有节点而t有节点i时i直接为新树
该位置节点，同一位置s无t有节点一样，而同一位置s、t分别有节点x、y时，新树该位置节点值为x.val+y.val

思路和代码: 
    递归函数定义: TreeNode merge(TreeNode s, TreeNode t) //返回分别以s、t为根节点的两棵树的merge的新树
    以两个指针遍历t1、t2，每次t1、t2都分别指向s、t的同一位置的节点
    对k位置来说：定义newTree-k、s-k、t-k分别表示新树、s、t在k位置的节点
        当s-k为null，t-k不为null时，newTree-k = t-k;
        当s-k不为null，t-k为null时，newTree-k = s-k;
        当s-k不为null且t-k不为null时:
            s-k.val += t-k.val; // 将s-k节点重复使用，作为新树k位置节点
            newTree-k = s-k;
            newTree-k.left = merge(s-k.left, t-k.left); // 对s-k、t-k的左子树merge后作为newNode的左子树
            newTree-k.right = merge(s-k.right, t-k.right); // 对s-k、t-k的右子树merge后作为newNode的右子树
```
##### Path Sum (Easy)
```
题目描述: 给一个二叉树和一个数sum，判断该二叉树是否存在一条从根节点到叶子节点的路径，
使得该路径上的所有节点值的累加和等于该数sum

思路: 枚举所有从根节点到叶子节点的路径并计算路径和，只要有一条路径的累加和等于给定的数则满足条件

递归函数定义：
    定义：boolean pathSum(TreeNode root, int target) // 判断在以root为根节点的二叉树中是否存在从root到某个叶子节点的路径使得该路径上所有节点累计和等于target
    思考：要计算路径上的节点值累加和，有两个累计路径和的方向
    (1)从根节点开始向下遍历累积,把累计和作为参数传递给递归函数本身;a.可以直接传递累计和currentSum给递归函数 b.传递目标值sum-累计和currentSum的差值给本身，
    子树只需要达到sum-currentSum的值就行了,这样参数更少
    (2)叶子节点向上返回值累计，累计和作为递归函数返回值返回给父节点:这种其实也是不科学的，因为这样的话递归函数需要返回一个list来保存每个不同路径的累计和
    ，比较麻烦，而且最顶层的递归函数还需要遍历所有路径累计和来判断是否存在有效路径，但是递归传累计和参数的方式就很方便了
    注意：这里的递归函数不同于计算树的深度，计算树的深度的递归函数是被调用的函数返回从叶子节点到左右子树的根节点的深度
    递归出口：叶子节点、null节点
```
``` 
(1) 代码写法1
    public boolean pathSum(TreeNode root, int target){
        // root == null时，root为叶子叶子的左右空指针，继然叶子节点没有返回true这里就应该返回false
        // 或者root为非叶子节点的某个空指针孩子，也应该返回false
        if(root == null){
            return false;
        }
        // 叶子节点, 且root-to-leaf路径和等于target
        if(root.left==null && root.right==null && target==root.val){
            return true;
        }
        return pathSum(root.left, target-root.val) || pathSum(root.right, target-root.val);
    }
```
```
(2) 代码写法2
    private boolean flag = false;
    public void pathSum(TreeNode root, int currentSum, int sum){
        // 说明root前面的节点都没有返回true，则这里肯定不满足条件了
        if(root == null){
            return;
        }
        currentSum += root.val;
        if(root.left==null && root.right==null && currentSum==sum){
            flag = true;
        }
        pathSum(root.left, currentSum, sum);
        pathSum(root.right, currentSum, sum);
    }
```
##### Path Sum III
```
题目描述: 给一个二叉树和一个数num，找到并返回所有满足规定条件的路径的数量
对路径的规定是：路径可以不从root节点开始，也可以不以叶子节点结束，但必须一直向下延展，且路径上所有节点值累计和等于给定的树num
对节点node，若node.left、node.right存在，则路径node.left->node->node.right不符合一直向下延展的规定

思路:  
对节点i，设f(i) = 从i开始向下的所有路径中等于sum的路径，累计二叉树中每个节点i的f(i)既为答案
两种写法，全局变量，和函数返回值返回有效路径数量
(1)全局变量:https://leetcode.com/submissions/detail/438932880/
(2) 返回值解法
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
        return ret;
    }
    private int pathSumStartWithRoot(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = 0;
        if (root.val == sum) ret++;
        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
        return ret;
    }
```

##### 总结
##### 树结构很适合写递归的解法，因为树本身就是递归定义的
##### (1)抽象思维
解决很多题目时，就是抽象的思考题目的意思，并不需要考虑是前序、中序、还是后序地去遍历树中的节点
比如"求树的高度这道题目"(Maximum Depth of Binary Tree)，正确的思考方式就是树高 = 1 + Math.max(左子树高+右子树高)，这就是一个前序遍历，
但是这是不是前序遍历并不重要，所以如果题目规定必须采用前序、中序、后续中的某一种来解决，就不需要考虑遍历顺序
##### (2)全局变量+递归函数
全局变量+递归函数：
有返回值的递归函数：递归函数的返回值只是为了完成递归函数的工作的中间产物，这和我们通常写的函数有些区别
不管是有返回值的递归还是void递归函数，全局变量才是递归函数的最终结果
##### (3)树结构题目-两种写法
1.void递归函数+全局变量：全局变量才是最终结果
2.有返回值的递归函数：返回值是最终结果
比如题目 Path Sum III
##### (4)考虑遍历顺序
当解决一个问题时，需要显式地遍历这个树地所有节点，然后对遍历的每个节点x做操作时
这时就可以来考虑是前序、后续、中序了，不过都一样
##### (5)对于路径类题目，计算路径长度或计算路径上所有节点val和时
1.给递归函数传入父节点累计和
2.对子节点调用递归函数时，将目标sum更新为sum-父节点累计和
##### (6)路径类问题，对于从root节点出发且可能会多个符合条件的返回值递归函数写法

##### (7)树类问题，第一关键是思路(难点的题目思路比较复杂)，第二关键是对于code，定义好递归函数的返回值和递归函数的作用
##### (8)树类问题，递归函数的定义就是数学模型的定义，对于有返回值的递归函数这个返回值是什么很关键，返回值可能就是最终结果，也可能只是为了递归函数真正的工作做准备
```
    private int pathSumStartWithRoot(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = 0;
        if (root.val == sum) ret++;
        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
        return ret;
    }
```
#### 2021-1-06
##### Subtree of Another Tree
```
题目描述: 给两颗二叉树s、t，判断是否存在s的一颗子树s1，让s1和t的结构，对应位置的节点值完全一样，
s的子树的定义为s的任意的一个节点和该节点的所有后代子节点形成的树
思路:
```
##### Symmetric Tree 
```
题目描述: 给一颗二叉树，判断其是否为左右对称，既从中线折叠后可以重合(折叠后相同位置节点值相同)
思路: 
```
##### Minimum Depth of Binary Tree 
```
题目描述: 给一棵二叉树，求其最小深度，深度定义为从根节点到任意一个叶子节点的路径长度(路径节点数-1)
思路:
```
##### Sum of Left Leaves
```
题目描述: 给一棵二叉树，求其所有"左叶子"节点值的累加和
思路: 满足条件的节点必须是左节点，且是叶子节点
```
##### Longest Univalue Path
```
题目描述: 给一颗二叉树，求二叉树中的最长路径的长度(路径上节点数量-1)，这个路径不需要经过该树的根节点，也不一定要
经过任意一个父节点，但这个路径中的每个节点值都必须一样
思路:
```
##### House Robber III
```
题目描述: 给一棵二叉树，每个节点代表一个房子，小偷从根节点开始偷窃，规则是不能偷窃直接相连的两个
节点，否则小偷会被抓住，除了根节点无父节点外其他节点有且只有一个父节点
思路:
```
##### Second Minimum Node In a Binary Tree
```
题目描述: 找出二叉树中第二小的节点，所给二叉树满足，每个节点要嘛有0个孩子，要嘛有两个孩子
且有两个孩子的父节点parent的值parent.val = Math.min(leftChild.val, rightChild.val)
思路:
```